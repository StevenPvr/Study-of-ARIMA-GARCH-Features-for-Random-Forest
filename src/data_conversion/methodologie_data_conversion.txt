# Méthodologie de Conversion des Données S&P 500

## Objectif

Le module `data_conversion` transforme les données OHLCV individuelles des tickers en séries temporelles agrégées pondérées par la liquidité. Cette étape cruciale calcule les rendements logarithmiques pondérés du portefeuille S&P 500 avec prise en charge des modes statiques et sans biais d'anticipation (no-look-ahead bias).

## Sous-modules actifs

- `data_conversion.py` : Fonctions principales pour l'agrégation pondérée
- `utils.py` : Fonctions utilitaires pour validation, calculs de poids et normalisation
- `main.py` : Interface CLI pour l'exécution

## Fonctions principales

### `compute_weighted_log_returns()` (Mode statique - OBSOLÈTE)
- **⚠️ Dépréciée** : Utilise des poids statiques sur l'ensemble de l'échantillon
- **Problème** : Introduit un biais d'anticipation (look-ahead bias)
- **Usage** : Uniquement pour analyses descriptives

### `compute_weighted_log_returns_no_lookahead()` (Mode causal - RECOMMANDÉ)
- Utilise des poids de liquidité temporels variables sans biais d'anticipation
- Fenêtre glissante pour les poids de liquidité (défaut : 252 jours)
- **Anti-biais d'anticipation** : Les poids sont calculés uniquement avec les données passées

## Déroulé du pipeline (Mode No-Look-Ahead)

1. **Validation des entrées**
   - Vérification de l'existence du fichier source (`dataset_filtered.parquet`)
   - Validation des colonnes requises : `date`, `ticker`, `open`, `close`, `volume`
   - Contrôle que le DataFrame n'est pas vide

2. **Calcul des rendements individuels**
   - Calcul des rendements logarithmiques quotidiens pour chaque ticker : `log(close_t / close_{t-1})`
   - Gestion des valeurs problématiques (prix négatifs/zéro)

3. **Calcul des poids de liquidité temporels**
   - Fenêtre glissante configurable (défaut : 252 jours)
   - Poids basés sur la liquidité moyenne : `prix × volume`
   - **Exclusion de l'observation courante** pour éviter le look-ahead bias
   - Normalisation par date pour que Σ(poids) = 1

4. **Agrégation pondérée causale**
   - Combinaison des rendements individuels avec les poids passés
   - Calcul du rendement pondéré : `Σ(rendement_ticker × poids_ticker_passé)`
   - Génération d'une série temporelle univariée

5. **Calcul des prix pondérés (pour backtesting)**
   - Agrégation des prix de clôture pondérés par liquidité
   - Utilisés pour les calculs de performance et métriques financières

6. **Sauvegarde et export**
   - Export en CSV et Parquet : `weighted_log_returns.csv/parquet`
   - Colonnes : `date`, `weighted_log_return`, `weighted_closing`
   - Journalisation des métriques : nombre de tickers, période couverte, statistiques

## Principes méthodologiques clés

### Anti-biais d'anticipation (No Look-Ahead Bias)
- Les poids pour la date t utilisent uniquement les données jusqu'à t-1
- Simulation réaliste d'un portefeuille où les poids sont connus à l'avance
- Compatible avec les scénarios de trading en production

### Poids de liquidité adaptatifs
- Basés sur la liquidité moyenne dans une fenêtre glissante
- Adaptent automatiquement aux changements de composition du marché
- Gestion des tickers absents (poids redistribués)

### Robustesse temporelle
- Validation des sommes de poids (tolérance numérique)
- Tri chronologique systématique
- Gestion des valeurs manquantes et extrêmes

## Architecture technique

### Fonctions utilitaires clés
- `compute_rolling_liquidity_weights()` : Calcul des poids temporels
- `compute_weighted_aggregated_returns()` : Agrégation pondérée
- `compute_weighted_prices()` : Calcul des prix pondérés pour backtesting

### Gestion de la mémoire
- Calculs vectorisés avec pandas
- Traitement par groupes pour efficacité
- Gestion des gros volumes de données

## Tests automatisés

- Tests unitaires sur les calculs de poids et rendements
- Tests d'intégration pour les pipelines statique et causal
- Tests de robustesse avec données manquantes/corrompues
- Validation des propriétés statistiques (somme des poids = 1)
- Tests de non-régression du biais d'anticipation

## Points de vigilance

- **Performance computationnelle** : Fenêtres glissantes sur gros volumes
- **Choix de la fenêtre** : Impact sur la stabilité des poids (défaut : 252 jours)
- **Reproductibilité** : Paramètres centralisés dans `constants.py`
- **Migration** : Préférer le mode `no_lookahead` pour tout nouveau développement

## Sortie

Le module produit une série temporelle univariée prête pour ARIMA/GARCH :
- Format : Date × (Rendement pondéré, Prix pondéré)
- Fréquence : Quotidienne (jours ouvrés)
- Propriétés : Rendements continus, pondérés par liquidité passée, sans biais d'anticipation
- Utilisation : Input direct pour les modèles de prévision de volatilité
